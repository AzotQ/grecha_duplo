<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Лидерборд grecha_duplo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 40px auto; background-image: url(background.jpg) }
        h1 { text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 8px 12px; border: 1px solid #ccc; text-align: right; }
        th { background: #f4f4f4; }
        td.wallet { text-align: left; font-family: monospace; }
        .error { color: red; text-align: center; }
    </style>
</head>
<body>
<h1>Лидерборд grecha_duplo</h1>

<table id="leaderboard">
    <thead>
    <tr><th>№</th><th>Кошелек</th><th>Сумма</th></tr>
    </thead>
    <tbody></tbody>
</table>

<script>
    // Точка прокси
    const API_URL = '/api/grecha';

    // Жёстко заданная дата-время отсечения
    // Формат строки: "YYYY-MM-DDTHH:mm"
    // Изменяйте эту константу под нужный вам порог
    const SINCE_DATETIME = '2025-06-19T00:00';
    const SINCE_MS = new Date(SINCE_DATETIME).getTime();

    // Timestamp последнего реального запроса (вначале — 0)
    let lastFetch = 0;
    // Минимальный интервал между запросами — 5 минут
    const MIN_INTERVAL = 5 * 60 * 1000;

    async function fetchAndRender() {
        const now = Date.now();
        // Если с прошлого удачного запроса прошло меньше MIN_INTERVAL — пропускаем
        if (now - lastFetch < MIN_INTERVAL) {
            console.log('Пропускаем fetch — слишком часто:', ((now - lastFetch)/1000).toFixed(1), 'с назад');
            return;
        }
        lastFetch = now;  // фиксируем время перед реальным запросом

        try {
            const resp = await fetch(API_URL);
            const payload = await resp.json().catch(() => ({}));
            if (!resp.ok) throw new Error(payload.error || `Status ${resp.status}`);

            let data = Array.isArray(payload.transfers) ? payload.transfers : [];
            data = data.filter(tx => Number(tx.timestamp_nanosec)/1e6 >= SINCE_MS);

            // Группируем и делим amount на 1000
            const sums = data.reduce((acc, tx) => {
                const w   = tx.from;
                const raw = parseFloat(tx.amount);
                const amt = isNaN(raw) ? 0 : raw / 1000;
                acc[w] = (acc[w] || 0) + amt;
                return acc;
            }, {});

            const sorted = Object.entries(sums)
                .map(([wallet, total]) => ({ wallet, total }))
                .sort((a, b) => b.total - a.total);

            const tbody = document.querySelector('#leaderboard tbody');
            tbody.innerHTML = '';
            if (sorted.length) {
                sorted.forEach((item, idx) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
            <td>${idx + 1}</td>
            <td class="wallet">${item.wallet}</td>
            <td>${item.total.toLocaleString(undefined, {
                        minimumFractionDigits: 3, maximumFractionDigits: 3
                    })}</td>
          `;
                    tbody.appendChild(tr);
                });
            } else {
                tbody.innerHTML = `
          <tr><td colspan="3" class="error">
            Нет переводов после ${SINCE_DATETIME.replace('T',' ')}
          </td></tr>`;
            }

        } catch (err) {
            console.error('Client error:', err);
        }
    }

    // Первоначальный запуск
    window.addEventListener('DOMContentLoaded', () => {
        fetchAndRender();
        // Проверяем каждые 60 секунд, но fetch при этом реально пойдёт не чаще, чем 1×/5мин
        setInterval(fetchAndRender, 60 * 1000);
    });
</script>
</body>
</html>
